<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Sudoku Visualizer</title>
    <style>
        /* START General style */
        * {
            padding: 0px;
            margin: 0px;
        }

        input {
            color: rgb(102, 102, 102);
        }

        .cell input.active {
            border-color: rgb(141, 177, 255);
        }

        .cell input.succeeded {
            border-color: rgb(120, 255, 0);
        }

        .btn {
            border: none;
            box-sizing: border-box;
            display: inline-block;
            padding: 15px 20px;
            color: white;
            background-color: rgb(5, 28, 49);
            font-size: 20px;
            cursor: pointer;
        }

        .btn:hover {
            background-color: rgb(0, 81, 255);
            color: #fff;
            font-weight: 600;
        }

        .btn:active {
            background-color: rgb(0, 81, 205);
        }


        body {
            
            background-size: cover;
            background-color: rgb(13, 88, 150);

            font-family: Arial, Helvetica, sans-serif;
        }

        /* END General style */



        /* START Menu style */
        /* START Menu-style.General Style */
        #nav-bar {
            background-color: rgba(158, 41, 194, 0.699);
            text-align: center;
            opacity: 0.9;
            z-index: 2;
            position: relative;
        }

        #nav-bar li {
            position: relative;
            color: #fff;
            padding: 15px 20px;
            display: inline-block;
            min-width: 105px;
            font-size: 20px;
            font-weight: bold;
        }

        /* END Menu-style.General Style */

        /* START Menu-Style.heading "Sudoku Solver Visualizer"*/
        #nav-bar h2 {
            color: white;
            font-style: bold;
            padding: 10px;
            font-size: 50px;
        }

        /* END Menu-Style.heading "Sudoku Solver Visualizer"*/

        /* START Menu-Style.Speed Dropdown */
        #nav-bar li:hover {
            background-color: rgba(13, 88, 150, 0.795);
            cursor: pointer;
        }

        #nav-bar li:hover .sub-menu {
            display: block;
        }

        .sub-menu {
            position: absolute;
            left: 0;
            top: 53px;
            background-color: rgb(49, 155, 255);
            display: none;
            text-align: left;
            font-size: 20px;
            font-weight: bold;
        }

        /* END Menu-Style.Speed Dropdown */

        /* START Menu-Style.Algorithms dropdown */
        #nav-bar li:nth-child(6) {
            min-width: 210px;
        }

        #nav-bar li:hover .algo-sub-menu {
            display: block;
        }

        .algo-sub-menu {
            position: absolute;
            left: 0;
            top: 53px;
            background-color: rgb(49, 155, 255);
            display: none;
            text-align: left;
            font-size: 20px;
            font-weight: bold;
            min-width: 210px;
        }

        #nav-bar .algo-sub-menu li {
            min-width: 210px;
        }

        #nav-bar .algo-selected {
            min-width: 210px;
        }

        /* END Menu-Style.Algorithms dropdown */


        /* START algo-info style */
        .algo-info-class {
            background-color: rgb(49, 155, 255);
            word-wrap: break-word;
            margin-left: 2.5%;
            width: 25%;
            float: left;
            padding: 10px;
        }

        #algo-info {
            text-align: left;
            padding: 10px;
            margin-left: 15px;
            position: absolute;
        }

        #algo-info-info {
            color: #5d1212;
            font-family: Georgia, 'Times New Roman', Times, serif;
        }

        #algo-info-header {
            color: #5d1212;
            font-family: Georgia, 'Times New Roman', Times, serif;
            font-size: 20px;
            font-weight: 500;
            font-style: italic;
            text-align: center;
            align-items: center;
            margin: auto;
            margin-bottom: 5px;
        }

        /* END algo-info style */

        /* START main div style */
        /* START main-div.General Style */
        #main {
            margin-top: 40px;
            /* position: relative; */
            text-align: center;
            z-index: 0;
        }

        /* END main-div.General Style */

        /* START main-div.Table style */
        #grid {
            /* margin: auto; */
            margin: auto;
            border-collapse: collapse;
            width: 378px;
            height: 395px;
            border: 3px solid rgb(20, 116, 116);
        }

        table {
            margin: 1cm auto;
        }

        td {
            height: 30px;
            width: 30px;
            border: 1px solid rgb(155, 155, 255);
            text-align: center;
        }

        td:first-child {
            border-left: solid rgb(155, 155, 255);
        }

        td:nth-child(3n) {
            border-right: solid rgb(155, 155, 255);
        }

        tr:first-child {
            border-top: solid rgb(155, 155, 255);
        }

        tr:nth-child(3n) td {
            border-bottom: solid rgb(155, 155, 255);
        }

        .cell input {
            opacity: 0.9;
            display: inline-block;

            border: 5px solid rgba(158, 41, 194, 0.699);
            width: 40px;
            height: 40px;

            text-align: center;
            font-size: 30px;
        }

        #solve {
            margin-top: 30px;
            margin-left: 725px;
            width: 100px;
            height: 50px;
            color: #fff;
            font-size: 20px;
            font-weight: bold;
            background-color: rgba(158, 41, 194, 0.699);
        }

        #solve:hover {
            background-color: rgb(33, 160, 149);
        }

        /* END main-div.Table style */
    </style>
</head>

<body>

    <nav id="nav-bar">
        <h2>Sudoku Visualizer</h2>
        <li id="clear"><span>Clear</span>
        <li id="randomly-fill" onclick="clickedRandomlyFill()"><span>Randomly Fill</span>


        <li>
            <span class="selected">Speed</span>
            <ul class="sub-menu">
                <li class="speed-options">Fast</li>
                <li class="speed-options">Medium</li>
                <li class="speed-options">Slow</li>
                <li class="speed-options">Extra Slow</li>
            </ul>
        </li>

        <li>
            <span class="algo-selected">Algorithms</span>
            <ul class="algo-sub-menu">
                <li class="algo-options">Backtracking</li>

                <li class="algo-options">Reverse Backtracking</li>
            </ul>
        </li>
    </nav>

    <div id="main-container">

        <div id="algo-info">
            <div id="algo-info-header"></div>
            <div id="algo-info-info"></div>
        </div>
        <div id="main">
            <table id="grid">
                <tr class="row">
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>

                    <!--row-->
                </tr>

                <tr class="row">
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <!--row-->
                </tr>

                <tr class="row">
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <!--row-->
                </tr>

                <tr class="row">
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <!--row-->
                </tr>

                <tr class="row">
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <!--row-->
                </tr>

                <tr class="row">
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <!--row-->
                </tr>

                <tr class="row">
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <!--row-->
                </tr>
                <tr class="row">
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <!--row-->
                </tr>
                <tr class="row">
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <td class="cell"><input type="text" maxlength="1"></td>
                    <!--row-->
                </tr>
            </table>
        </div>

    </div>
    <button id="solve">Solve</button>
    <script>
        const subMenu = document.querySelector("#nav-bar").children[3].children[1];
        const speedButton = document.querySelector("#nav-bar").children[3].children[0];
        const liAroundSpeedDropdownMenu = document.querySelector("#nav-bar").children[3];
        const liAroundAlgoDropdownMenu = document.querySelector("#nav-bar").children[4];
        const solve = document.querySelector("#solve");
        const clear = document.querySelector("#clear");
        const randomlyFill = document.querySelector("#randomly-fill");
        const grid = document.querySelector("#grid");
        const inputs = document.getElementsByTagName('input');
        const algoInfo = document.querySelector("#algo-info-info");
        const algoHeader = document.querySelector("#algo-info-header");
        const algoInfoWraper = document.querySelector("#algo-info");

        // START Dropdown menu (Speed)
        const speedDropDown = document.querySelector("span.selected");
        const speedOptions = document.querySelectorAll('.speed-options');
        speedOptions.forEach(e => {
            e.addEventListener("click", () => {
                let value = e.innerHTML;
                speedDropDown.innerHTML = value;
            });
        });
        // DONE Dropdown menu (Speed)

        // START Dropdown menu (Algorithms)
        const algorithmsDropDown = document.querySelector("span.algo-selected");
        const algorithmsOptions = document.querySelectorAll('.algo-options');
        algorithmsOptions.forEach(e => {
            e.addEventListener("click", () => {
                let value = e.innerHTML;
                algorithmsDropDown.innerHTML = value;
                setAlgoInfo(value);
            });
        });
        // DONE Dropdown menu (Algorithms)

        // CONSTANT SPEED (The lower the faster. It actually is the time lapse between 2 animation)
        const FAST_SPEED = 1;
        const MEDIUM_SPEED = 10;
        const SLOW_SPEED = 50;
        const EXTRA_SLOW_SPEED = 150;

        // Add eventListener
        clear.addEventListener('click', clickedClear);
        randomlyFill.addEventListener('click', clickedRandomlyFill);
        solve.addEventListener('click', clickedSolve);

        function setAlgoInfo(algoName) {
            let description = "";

            if (algoName === "Backtracking") {
                description = "Sudoku Backtracking is a recursive algorithm which goes through each cells and sequentially assigns numbers from 1 to 9 if the cell is empty.<br/><br/>" +

                    "After each assignment, we check whether the current board is valid, and recursively go to the next cell if it is.<br/><br/>" +

                    "If we reach the last (bottom right corner) cell, and we have a valid assignment to that cell, we have a solution.<br/><br/>" +

                    "If we have tried all possible values from 1 to 9 on a cell, and no values lead to a solution, we backtrack (go back to the previous cell) and continue where we left off (continue to assign the next number).";
            }

            else if (algoName === "Reverse Backtracking") {
                description = "Reverse Backtracking is a modified version of the Backtracking algorithm. Instead of picking the next cell top to bottom and left to right, it picks the next cell bottom to top, right to left.<br/><br/>" +

                    "The Algorithm tends to do well when the majority entries near the bottom are prefilled.<br/><br/>" +

                    "In terms of the average time taken to solve a Sudoku puzzle, there is no substantial difference between Reverse Backtracking and normal Backtracking";
            }



            algoInfoWraper.classList.add('algo-info-class');

            algoHeader.innerHTML = "Algorithm Information";
            algoInfo.innerHTML = description;
        }



        //-------------------------------------------------START ClickedClear-------------------------------------------------
        //-------------------------------------------------START ClickedClear-------------------------------------------------
        //-------------------------------------------------START ClickedClear-------------------------------------------------

        // This function clears all timeouts, animation colors and allow to press Solve and Speed again
        function clickedClear(e) {
            clearAllTimeOuts();
            clearAllColors();
            clearAlgoInfo();
            setAllowSolveSpeedAndAlgorithms();
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    grid.rows[i].cells[j].firstChild.value = "";
                }
            }
        }

        function clickedClearExceptAlgoInfo() {
            clearAllTimeOuts();
            clearAllColors();
            setAllowSolveSpeedAndAlgorithms();
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    grid.rows[i].cells[j].firstChild.value = "";
                }
            }
        }

        // This function delete all timeOut (animations)
        function clearAllTimeOuts() {
            while (timeOutIDSameForAnyAnimation >= 0) {
                clearTimeout(timeOutIDSameForAnyAnimation);
                timeOutIDSameForAnyAnimation--;
            }
        }

        // Clear all colors from animations
        function clearAllColors() {
            for (let i = 0; i < inputs.length; i++) {
                inputs[i].classList.remove('active');
                inputs[i].classList.remove('succeeded');
            }
        }

        // Clear Algo description   
        function clearAlgoInfo() {
            algoInfoWraper.classList.remove('algo-info-class');
            algoHeader.innerHTML = "";
            algoInfo.innerHTML = "";
        }

        // Allow to click solve, choose speed and algorithms again
        function setAllowSolveSpeedAndAlgorithms() {
            solve.setAttribute("style", "cursor: pointer"); // Allow to click solve button

            solve.addEventListener('click', clickedSolve);  // Add back eventListener for solve button

            liAroundSpeedDropdownMenu.setAttribute("style", "cursor: pointer"); // enable dropdown (pointerEvent)
            liAroundAlgoDropdownMenu.setAttribute("style", "cursor: pointer"); // enable dropdown (pointerEvent)
        }

        // Not allow to click solve, choose speed and algorithms
        function setNotAllowSolveSpeedAndAlgorithms() {
            solve.style.backgroundColor = "red";    // Turn solve button to red
            solve.style.cursor = "not-allowed";     // Change cursor mode
            solve.removeEventListener('click', clickedSolve);   // Remove any function when click

            liAroundSpeedDropdownMenu.setAttribute("style", "pointer-events: none"); // Cannot click Speed menu
            liAroundAlgoDropdownMenu.setAttribute("style", "pointer-events: none"); // Cannot click Algorithms menu
        }


        //-------------------------------------------------DONE ClickedClear-------------------------------------------------
        //-------------------------------------------------DONE ClickedClear-------------------------------------------------
        //-------------------------------------------------DONE ClickedClear-------------------------------------------------

        //---------------------------------------------START clickedRandomlyFill----------------------------------------------
        //---------------------------------------------START clickedRandomlyFill----------------------------------------------
        //---------------------------------------------START clickedRandomlyFill----------------------------------------------

        // This function is called when we click the "Randomly-fill" button
        function clickedRandomlyFill(e) {
            clickedClearExceptAlgoInfo();  // Clear the board first
            fill80Succeed20NotSure();
        }

        // Fill the board with 80% probability that we will have a solution and 20% truly random
        function fill80Succeed20NotSure() {
            if (Math.random() < 0.8) // 80% guaranttee solution
            {
                hasSolutionMatrix = [[8, 2, 5, 1, 9, 7, 3, 4, 6],
                [6, 1, 7, 3, 4, 2, 9, 5, 8],
                [4, 3, 9, 6, 8, 5, 7, 1, 2],
                [1, 9, 6, 5, 3, 8, 2, 7, 4],
                [2, 8, 3, 7, 6, 4, 5, 9, 1],
                [5, 7, 4, 9, 2, 1, 8, 6, 3],
                [7, 6, 1, 2, 5, 3, 4, 8, 9],
                [9, 4, 2, 8, 7, 6, 1, 3, 5],
                [3, 5, 8, 4, 1, 9, 6, 2, 7]];
                newSudokuQuiz = mixSudokuQuiz(hasSolutionMatrix);
                printBoardOnWeb(newSudokuQuiz);
            }
            else // The rest 20% Just randomly fill
            {
                matrix = generateRandomBoard(); // This is random
                printBoardOnWeb(matrix);
            }
        }

        // This function randomly swaps rows and columns of a sudoku board with a specific rule
        // Rule: If a sudoku board has a solution, if we swap 2 rows (or 2 columns)  within the same
        // 3x9 (or 9x3) "rectangle", our sudoku will preserve its solvability
        function mixSudokuQuiz(matrix) {
            let numEntries = 20 + Math.floor((Math.random() * 8));  // Number of entries to be kept
            mixRowsAndColumns(matrix);  // Mix board
            keepSomeEntries(matrix, numEntries);    // Keep some random Entries
            return matrix;
        }

        // This function randomly swaps different rows (or columns) with the "appropriate" rows(or columns)
        function mixRowsAndColumns(matrix) {
            let numSwap = Math.floor(Math.random() * 15) + 1; // Swap 1-10 times
            while (numSwap > 0) {
                let num1 = Math.floor(Math.random() * 9);   // Pick a row (or column) from 0 to 8
                let num2 = Math.floor(num1 / 3) * 3 + Math.floor(Math.random() * 3); // Pick another row (column) in the right range
                if (Math.random() < 0.5) {
                    swapRow(matrix, num1, num2);
                }
                else {
                    swapCol(matrix, num1, num2);
                }
                numSwap--;
            }
        }

        // Randomly keep some entries out of a full sudoku board
        function keepSomeEntries(matrix, numEntriesKeep) {
            let numEntriesDelete = 81 - numEntriesKeep;
            for (let i = 0; i < numEntriesDelete; i++) {
                while (true) {
                    let row = Math.floor(Math.random() * 9);
                    let col = Math.floor(Math.random() * 9);
                    if (matrix[row][col] != 0) {
                        matrix[row][col] = 0;
                        break;
                    }
                }
            }
        }

        // Swap 2 row
        function swapRow(matrix, row1, row2) {
            for (let i = 0; i < 9; i++) {
                let temp = matrix[row1][i];
                matrix[row1][i] = matrix[row2][i];
                matrix[row2][i] = temp;
            }
        }

        // Swap 2 col
        function swapCol(matrix, col1, col2) {
            for (let i = 0; i < 9; i++) {
                let temp = matrix[i][col1];
                matrix[i][col1] = matrix[i][col2];
                matrix[i][col2] = temp;
            }
        }

        // This function actually generate a random board
        function generateRandomBoard() {
            let numFill = 20 + Math.floor((Math.random() * 8));
            let matrix = new Array(9);

            for (let i = 0; i < 9; i++) {
                matrix[i] = new Array(9);
                for (let j = 0; j < 9; j++) {
                    matrix[i][j] = "";
                }
            }

            while (true) {
                if (numFill === 0)
                    break;
                let i = Math.floor(Math.random() * 9);
                let j = Math.floor(Math.random() * 9);
                if (matrix[i][j] == "") {
                    matrix[i][j] = Math.floor(Math.random() * 9) + 1;
                    if (canBeCorrect(matrix, i, j))
                        numFill--;
                    else
                        matrix[i][j] = "";
                }
            }
            return matrix;
        }
        //---------------------------------------------DONE clickedRandomlyFill----------------------------------------------
        //---------------------------------------------DONE clickedRandomlyFill----------------------------------------------
        //---------------------------------------------DONE clickedRandomlyFill----------------------------------------------

        //------------------------------------------------START clickedSolve-------------------------------------------------
        //------------------------------------------------START clickedSolve-------------------------------------------------
        //------------------------------------------------START clickedSolve-------------------------------------------------

        // This function is called when we click the "Solve" button
        // It will call the proper algorithms, and using the proper speed
        // By default, it will use Backtracking at Medium Speed
        function clickedSolve(e) {
            // Verify input first
            if (verifyInput() == false)
                return;

            if (speedDropDown.innerHTML === "Speed") // If haven't set speed
                speedDropDown.innerHTML = "Medium"; // Set to medium

            if (algorithmsDropDown.innerHTML === "Algorithms") // If haven't set Algorithms yet
            {
                algorithmsDropDown.innerHTML = "Backtracking"; // Set to Backtracking
                setAlgoInfo("Backtracking");                    // And turn on info
            }

            let currentAlgo = getCurrentAlgorithm();

            // Reverse Backtracking and Spiral Backtracking are just different variation of Backtracking
            if (currentAlgo === "Backtracking" || currentAlgo === "Reverse Backtracking" || currentAlgo === "Spiral Backtracking")
                solveByBacktracking(e, currentAlgo);
            // else if(currentAlgo === "BFS")
            //solveByBFS(e);
            //else if(currentAlgo === "Dancing Links")
            //  solveByDancingLinks(e);
        }

        //------------------------------------------------START Backtracking-------------------------------------------------
        //------------------------------------------------START Backtracking-------------------------------------------------
        //------------------------------------------------START Backtracking-------------------------------------------------
        function solveByBacktracking(e, currentAlgo) {
            backtrackingCountToPreventHanging = 0;
            setNotAllowSolveSpeedAndAlgorithms();   // Disable some buttons
            let matrix = readValue();               // Read values from web board

            backtracking(matrix, currentAlgo);                    // Solving sudoku

            let timeAfterAllDone = (++backtrackingTimeCount) * backtrackingDuration;

            if (allBoardNonZero(matrix))             // If We actually have a solution
            {
                if (currentAlgo === "Backtracking" || currentAlgo === "Reverse Backtracking")
                    succeededNormalAnimation(backtrackingTimeCount, backtrackingDuration);
                else if (currentAlgo === "Spiral Backtracking")
                    succeededSpiralAnimation(backtrackingTimeCount, backtrackingDuration);
            }
            else {
                timeOutIDSameForAnyAnimation = setTimeout(alertNoSolution, timeAfterAllDone);
                timeOutIDSameForAnyAnimation = setTimeout(setAllowSolveSpeedAndAlgorithms, timeAfterAllDone);
            }

        }

        var backtrackingCountToPreventHanging = 0;
        var backtrackingDuration = 1;
        var backtrackingTimeCount = 0;
        var timeOutIDSameForAnyAnimation = 0;
        function backtracking(matrix, currentAlgo) {
            // Setting Speed
            backtrackingDuration = MEDIUM_SPEED;
            if (speedDropDown.innerHTML === 'Fast') backtrackingDuration = FAST_SPEED;
            else if (speedDropDown.innerHTML === 'Medium') backtrackingDuration = MEDIUM_SPEED;
            else if (speedDropDown.innerHTML === 'Slow') backtrackingDuration = SLOW_SPEED;
            else if (speedDropDown.innerHTML === 'Extra Slow') backtrackingDuration = EXTRA_SLOW_SPEED;


            backtrackingTimeCount = 0;  // Time count for scheduling animation

            // Find out which entries are user input (isFixed===true), which are empty (isFixed===false)
            let isFixed = new Array(9);
            for (let i = 0; i < isFixed.length; i++) {
                isFixed[i] = new Array(9);
                for (let j = 0; j < isFixed[i].length; j++) {
                    if (matrix[i][j] !== 0) {
                        isFixed[i][j] = true;
                    }
                    else {
                        isFixed[i][j] = false;
                    }
                }
            }

            let data = { cont: true };
            let startingRow = -1;
            let startingCol = -1;
            if (currentAlgo === "Backtracking") {
                startingRow = 0;
                startingCol = 0;
            }
            else if (currentAlgo === "Reverse Backtracking") {
                startingRow = matrix.length - 1;
                startingCol = matrix.length - 1;
            }
            else if (currentAlgo === "Spiral Backtracking") {
                startingRow = 0;
                startingCol = 0;
            }
            backtrackingHelper(matrix, isFixed, startingRow, startingCol, data, currentAlgo);
        }

        function backtrackingHelper(matrix, isFixed, row, col, data, currentAlgo) {

            // If !data.cont or having our current entry at (row, col) lead to a clearly invalid sudoku board
            if (data.cont === false || !canBeCorrect(matrix, row, col))  // 1st stopping point
                return;

            // Backtracking is a naive solution.
            backtrackingCountToPreventHanging++;
            if (backtrackingCountToPreventHanging > 100000)  // Runs for too long without a solution
            {
                data.cont = false;  // Set the flag so that the rest of the recursive calls can stop at "stopping points"
                stopSolveSudokuBacktracking(currentAlgo); // Stop the program
                return;
            }

            if ((currentAlgo === "Backtracking" && row === 8 && col === 8)
                || (currentAlgo === "Reverse Backtracking" && row === 0 && col === 0))  // If reach the last entry
            {
                if (isFixed[row][col])   // The last entry is user input
                {
                    if (canBeCorrect(matrix, row, col))  // And it doesn't create an invalid board
                    {
                        data.cont = false;  // Yesss!! Found the solution!
                    }
                    return;
                }
                else    // If it is not user input
                {
                    for (let i = 1; i <= 9; i++) {
                        matrix[row][col] = i; // Try 1-9
                        timeOutIDSameForAnyAnimation = setTimeout(fillCell, (backtrackingTimeCount++) * backtrackingDuration, row, col, i);
                        if (canBeCorrect(matrix, row, col)) // If found the solution
                        {
                            data.cont = false;
                            return;
                        }
                    }
                    timeOutIDSameForAnyAnimation = setTimeout(emptyCell, (backtrackingTimeCount++) * backtrackingDuration, row, col);
                    matrix[row][col] = 0;   // Otherwise, backtrack, reset the current entry to 0
                }
            }

            // Compute newRow and new Column coressponding to currentAlgo
            let newRow = -1;
            let newCol = -1;
            if (currentAlgo === "Backtracking") {
                // Fill from left to right, from top to bottom
                newRow = (col === 8) ? row + 1 : row;
                newCol = (col === 8) ? 0 : col + 1;
            }
            else if (currentAlgo === "Reverse Backtracking") {
                // Fill from right to left, bottom to top
                newRow = (col === 0) ? row - 1 : row;
                newCol = (col === 0) ? 8 : col - 1;
            }

            // If this entry is user input and is valid
            if (isFixed[row][col] && canBeCorrect(matrix, row, col)) {
                backtrackingHelper(matrix, isFixed, newRow, newCol, data, currentAlgo); // Continue next entry
            }
            // If it is empty
            else {
                for (let i = 1; i <= 9; i++) {
                    if (data.cont === false) // Stopping entry 2
                        return;
                    timeOutIDSameForAnyAnimation = setTimeout(fillCell, (backtrackingTimeCount++) * backtrackingDuration, row, col, i);
                    matrix[row][col] = i; // Try 1-9

                    if (canBeCorrect(matrix, row, col))  // If any of those values (1-9) can be valid
                    {
                        backtrackingHelper(matrix, isFixed, newRow, newCol, data, currentAlgo); // recursively move on to the next cell
                    }
                }
                if (data.cont === false) // Stopping entry 3
                    return;
                timeOutIDSameForAnyAnimation = setTimeout(emptyCell, (backtrackingTimeCount++) * backtrackingDuration, row, col);
                matrix[row][col] = 0; // Backtrack, set entry to 0
            }
        }

        // This function is called when backtracking function is running for too long
        // It will stop the function to prevent hanging
        function stopSolveSudokuBacktracking(currentAlgo) {
            if (currentAlgo === "Backtracking") {
                alert("Backtracking is a Naive Algorithm. It tends to do well when the majority of entries near the top are prefilled.\nThe program is taking too long to find a solution. It will be terminated to prevent hanging.");
            }
            else if (currentAlgo === "Reverse Backtracking") {
                alert("Reverse Backtracking is a Naive Algorithm. It tends to do well when the majority of entries near the bottom are prefilled.\nThe program is taking too long to find a solution. It will be terminated to prevent hanging.");
            }

            clickedClear();
        }

        // Normal animation when we have found the solution 
        function succeededNormalAnimation(currentTimeCount, currentDuration) {
            let currentTime = currentTimeCount * currentDuration;
            let succeededDuration = 20;
            let newCount = 0;
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    timeOutIDSameForAnyAnimation = setTimeout(colorCell,
                        currentTime + (newCount++) * succeededDuration, row, col);
                }
            }
            timeOutIDSameForAnyAnimation = setTimeout(setAllowSolveSpeedAndAlgorithms, currentTime + (newCount++) * succeededDuration);
        }

        //------------------------------------------------END Backtracking-------------------------------------------------
        //------------------------------------------------END Backtracking-------------------------------------------------
        //------------------------------------------------END Backtracking-------------------------------------------------

        //--------------------------------------------START Best-First Search----------------------------------------------
        //--------------------------------------------START Best-First Search----------------------------------------------
        //--------------------------------------------START Best-First Search----------------------------------------------

        class EntryData {
            constructor(row, col, choices) {
                this.row = row;
                this.col = col;
                this.choices = choices;
            }

            setData(row, col, choices) {
                this.row = row;
                this.col = col;
                this.choices = choices;
            }
        }

        // This function is called by clickedSolve. It will call bfs() to solve sudoku by Best-First Search
        // IDEA OF BEST-FIRST-SEARCH:
        // - For each next move, pick the "Best" entry to try 1-9 by iterate through the whole board
        // and find the entry with the least number of possibilities


        function uncoverColumn(topColumnNode) {
            // Please see Knuth's Paper for better understanding http://www-cs-faculty.stanford.edu/~uno/papers/dancing-color.ps.gz
            // (Page 6 - Covering a column)

            let c = topColumnNode; // For shorter writing

            let i = c.up;
            while (i != c) {
                let j = i.left;
                while (j != i) {
                    j.header.size++;

                    j.down.up = j;
                    j.up.down = j;

                    j = j.left;
                }
                i = i.up;
            }
            c.right.left = c;
            c.left.right = c;
        }

        //-------------------------------------------------END clickedSolve--------------------------------------------------
        //-------------------------------------------------END clickedSolve--------------------------------------------------
        //-------------------------------------------------END clickedSolve--------------------------------------------------

        //-----------------------------------------------START HelperFunction------------------------------------------------
        //-----------------------------------------------START HelperFunction------------------------------------------------
        //-----------------------------------------------START HelperFunction------------------------------------------------
        function emptyCell(row, col) {
            inputs[row * 9 + col].classList.remove('active');
            grid.rows[row].cells[col].firstChild.value = "";
        }

        function fillCell(row, col, val) {
            inputs[row * 9 + col].classList.add('active');
            grid.rows[row].cells[col].firstChild.value = val;
        }

        function colorCell(row, col) {
            inputs[row * 9 + col].classList.add('succeeded');
        }

        function canBeCorrect(matrix, row, col) {
            // Check row
            for (let c = 0; c < 9; c++) {
                if (matrix[row][col] !== 0 && col !== c && matrix[row][col] === matrix[row][c])
                    return false;
            }

            // Check column
            for (let r = 0; r < 9; r++) {
                if (matrix[row][col] !== 0 && row !== r && matrix[row][col] === matrix[r][col])
                    return false;
            }

            // Check 3x3 square
            let r = Math.floor(row / 3);
            let c = Math.floor(col / 3);
            for (let i = r * 3; i < r * 3 + 3; i++) {
                for (let j = c * 3; j < c * 3 + 3; j++) {
                    if ((row !== i || col !== j) && matrix[i][j] !== 0 && matrix[i][j] === matrix[row][col])
                        return false;
                }
            }

            return true;
        }

        function allBoardNonZero(grid) {
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    if (grid[i][j] === 0)
                        return false;
                }
            }
            return true;
        }

        // Read value from web board to 2d array
        function readValue() {
            let matrix = new Array(9);
            for (let i = 0; i < 9; i++) {
                matrix[i] = new Array(9);
                for (let j = 0; j < 9; j++) {
                    val = grid.rows[i].cells[j].firstChild.value;
                    matrix[i][j] = (val === "") ? 0 : parseInt(val);
                }
            }
            return matrix;
        }

        // See if the input is valid
        function verifyInput() {
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    let val = grid.rows[i].cells[j].firstChild.value;

                    if ((val != "" && Number.isNaN(parseInt(val))) || 0 >= parseInt(val) || 9 < parseInt(val)) {
                        alert("Please enter numbers from 1 to 9");
                        return false;
                    }
                }
            }
            return true;
        }

        // Get the current Algorithm from Algorithms dropdown menu
        function getCurrentAlgorithm() {
            let currentAlgo = "Backtracking";   // Default is Backtracking

            if (algorithmsDropDown.html === "Backtracking") currentAlgo = "Backtracking";
            else if (algorithmsDropDown.innerHTML === "Best First Search") currentAlgo = "BFS";
            else if (algorithmsDropDown.innerHTML === "Dancing Links") currentAlgo = "Dancing Links";
            else if (algorithmsDropDown.innerHTML === "Reverse Backtracking") currentAlgo = "Reverse Backtracking";
            else if (algorithmsDropDown.innerHTML === "Spiral Backtracking") currentAlgo = "Spiral Backtracking";

            return currentAlgo;
        }

        function alertNoSolution() {
            alert("No Solution!");
        }

        function printBoardOnWeb(matrix) {
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    if (matrix[i][j] == 0)
                        grid.rows[i].cells[j].firstChild.value = "";
                    else
                        grid.rows[i].cells[j].firstChild.value = matrix[i][j];
                }
            }
        }
//-----------------------------------------------END HelperFunction------------------------------------------------
//-----------------------------------------------END HelperFunction------------------------------------------------
//-----------------------------------------------END HelperFunction------------------------------------------------
    </script>
</body>

</html>